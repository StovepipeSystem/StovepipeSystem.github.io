---
layout: post
title:  "Part 1 – What is Software Development"
date:   2016-06-19 18:01:00 -0500
categories:
---

## Session 1 – The triangle of development

If you are reading this post, it means that you have an interest in software development. If you just thought about learning programming a few minutes ago, start by asking yourself these questions:

What do I think software development is like?
What is involved in writing an application?
Is there any limits to what I can create?
Your answers might be very different depending on the millage you have on the subject. At first, I thought that writing software was only about writing code, that I had to run the code and play with it until it worked the way I wanted, and finally that there was no limit to what I could create. Well, after more than 10 years of playing with code and developing various kind of software, it turns out I was pretty far off.

### What it is like?

The most basic impression you might get from software development is that it is simply putting together a set of simple instructions to manipulate data. All programs are just a basic stream of instructions executed one after the other by your computer. Said like this, it looks very simple, but reality is way different. Most programs are so large that managing the code becomes an issue. Its just like trying to cook diner: easy for 2, need planning for 20, insane for 200.

In fact, software development is not very far off from building a house or baking a cake. In every cases you have tools, techniques and recipes. In construction, the tools would be your hammer, drill and truck. The techniques are how you use them: drill goes with screws, hammer goes with nails, ratchet kit is all organized, etc. Finally the recipes would be the various constructions pattern you use to get to your goal using your tools: Building the structure of a wall or making stairs. This makes writing code very different from just putting a bunch instructions one after the other. Yes you still need to punch all of those nails and cut all of this wood but there is also so much more to take care off. It’s not just about writing code anymore, it is about organizing it, making it run fast, be efficient and most importantly readable. It is not so much about the ingredients that you use to cook, it is about how you mix them without making a mess of the kitchen while still making an absolutely gorgeous cake and keeping it cheap so that you can make a profit.

### How do you get there?

Since writing code involve so much more than just typing in a text editor, you would be right to think that there is a lot more than trying your app out to make sure it works before releasing it to the world. While you need to test your code, there are tools that exists to help you work faster and with greater accuracy. In fact, you will use these tools three to five times more than your own app during both the development and maintenance phases of your project. For instance, I have been writing thousands of lines of code for a project of mine and I have yet to be able to start an application to test them. I only rely on those tools to make sure that everything works as it should. To give you an idea of the advantages of this technique, I have compiled some statistics from this project. In 15 seconds, I can test over 90% of the entirety of the code I have written so far. The other 10% is mostly code that cannot be tested easily. There are over 300 individual tests regrouped in 40 easy to browse categories. This would take days to run manually and would also be error prone. Instead, these tests runs every time I want. This could be 15 seconds apart or 15 minutes apart.

You will also have to plan ahead for the more complex parts of your application. Design and architecture is not just for brick-and-mortar stores. Again, you will find countless tools to help you with your planning but this time it will mostly boil down to your own problem solving abilities. If you think writing code is a repetitive job, this is the part where you get to be creative and have fun. You will need to put everything that you have learned on the table and figure out where the simplest and most extensible path to success are. This is the direction this course wants to take. I will try to guide you so that you understand the semantics of the code to help you write better software and not just tell you what the basic building blocks are.

### Where is the red-line?

Finally, even though your imagination might be infinite, there are limits to what you can write. Just like in the real world where constructing a thousand-stories-tall tower of I-beams, glass and concrete would be nearly impossible, physics still applies inside your computer. You can only do so much processing in 25 ms which is the time you would have in a game to produce a high quality real-time rendering of a 3D world with dozens of AI-driven enemies rushing at you while keeping a steady 45 FPS. Hopefully, this will help you understand the difficulties behind making your average 3D game. Then there is the whole P != NP thing where some problems that seems very simple gets so insanely complicated so quickly as you add more possibilities that they can barely be solved by today’s computers in a reasonable time. Basically, any problems where you know the solution but not how to get there falls into this category. For instance, path-finding is one of those problems. How many paths is there between you and your enemy. If you consider every single variation to the very pixel, and try to analyse the data to pick the best route, there is a pretty good chance that you will bust your 25 ms per frame budget. Given enough time, your power will always be limitless. You could crack any password, mine every bitcoin, track every car, predict the temperature of every molecule in the atmosphere years in advance but you will more than often end up having to make concessions. It could be a financial red-line, a latency red-line or even a social red-line. It will vary depending on your projects but it will always be there lurking in the shadows.

![Art + Tools + Algorithms = Software]({{ site.url }}/assets/2016-06-19-part-1-what-is-software-development/1-triangle.png)

*Art + Tools + Algorithms = Software*

## So what IS software development? Craft!

Considering everything that I have mentioned so far, software development is the art of using the right tools and algorithms to attain a specific set of goals while still being able to react to changing needs. Some times, it also has to do with figuring out those goals in the first place, but this is not a management or analysis class, this is a development class so we will skip over that part for now. In more concrete, Object Oriented programming jargon, it is about structuring your code by putting the right kind of responsibilities inside the right objects to accomplish a given task, basically creating your own tools as master-blacksmiths used to do back in the days.

Modern software development is usually done in what we call Object Oriented code. There are other kinds of programming paradigm, but we will get to those later. The most important aspect of Object Oriented Programming (OOP for short) is that most if not all the code that you write is organized inside a virtual concept of objects.

An object is a block of code with a single responsibility that defines properties and actions upon itself. Indeed, in the OOP world, not all code is created equal. Before OOP came along, all elements of your code could be called at any time. This made it really hard for programs to stay stable as they grew larger and larger. You might have a set of instructions designed to work together in a specific order and someone could jump right in the middle. Imagine the following program:

Load some data
Do something with the data
Store the data
If a developer wants to add a feature to the program, they might want to use the code that you already wrote. Code reuse is a good thing, but in this case, they could jump anywhere in the code. What would happen if they jumped to the second line of this example? The computer have to do something with the data but, there is no data. It never loaded it!

![Art + Tools + Algorithms = Software]({{ site.url }}/assets/2016-06-19-part-1-what-is-software-development/2-gotos.png)

*Wheehe… oh sh…*

Obviously, this is a gross oversimplification and code like this only existed in the early days of computing. We quickly created safer ways to jump around the code. For instance, we created labels and go tos. Instead of jumping to a specific line of code, you could then go to a specific label somewhere in the code. This also fixed an other problem: what if a developer add a line in the middle of already existing code? You used to have to update all of your jumps to match the proper lines. Missing just one could have catastrophic results.

Eventually, labels and gotos evolved into higher level constructs called functions. A function is simply a named block of executable code with multiple inputs and outputs. This fixed an other issue that labels had: there was no way to know what external data this block of code needed to work and where it would put the result. This is a great improvement, but it still have one massive problem. Those functions can still interact with any other function in the entire code base. Even grouped in functions, one million lines of code is still one million lines of code. It is hard to know what needs to be tested when something changes. Even worst, functions could still interact with external data without going through explicit inputs and outputs so there was still the possibility of corrupting the state of the application.

![Art + Tools + Algorithms = Software]({{ site.url }}/assets/2016-06-19-part-1-what-is-software-development/3-object.png)

*Properties and Actions of a TeaCup object*

This is where OOP comes in. By regrouping all of your code inside simple, single-responsibility objects, you can easily see how the code interact, add features or fix bugs. The downside is that in OOP is that code now have a concept of privileges. Some code can be executed, other instructions only describes the program. Part of the code can access elements other parts cannot. This safety is what makes multi-million and even small programs manageable.

A hyperlink is a good example of a simple object. It has properties like a text, a foreground color and a destination. It has actions like display on screen and navigating to the destination when clicked. An other good, more abstract example is a web browser. While it can do many things, it does not take care of all that a web page can do. It has the responsibility of displaying the resulting page to the user and getting the user actions to the code that take care of the page itself. Its job is to synchronizes the user and the content but it does not process the content by itself. It will trigger the process though, since this is done through a user action for which it has control over. This kind of self-imposed limitations are exactly what makes it simpler to understand what the code is doing.

Virtual object woks the same as real world objects. You do not actually drink coffee by itself and the cup containing it cannot be drank from if it contains nothing. In the same way, you should not expect a button to send data over the network by itself. This is the whole point of object oriented programming. The coffee cup, the coffee liquid, the button and the network communication system all have their specific responsibility. This helps you find what you are looking for because the last place where you would look for to send data on a network is in a button. Plus, pushing bits on a network card simply does not feels like it is related to the concept of sending a missile at your enemy in a video game which is an other example of the use of a button.

In the end, you will have dozens of objects to accomplish very specific or more generic tasks and this is OK. It is just like a massive box full of LEGOs… If you ever played LEGOs, you know what that means. Hours and hours of digging through tons and tons of small pieces to find just the right one that you need and somehow, they all look like they could be useful somewhere in your project. That is when you start to cry and wonder why you never took the time to organize all of those pieces in neat little boxes. This is where virtual objects really shines. In the real world, it would be very costly to go out and buy those boxes. In the virtual world, creating a new object or folder costs only a handful of bytes… in a universe of terabyte-sized storage. To give you a better idea of the difference in order of magnitude, if an ant was a byte, you would only need a handful of them to create your box where you would have a hundred-floor-tall building worth of ants that you could use.

## The basics of tool making

With this background in mind, we can finally begin our first lesson. Let us start with a little bit of vocabulary. In C# (and most OOP languages), a class is a blueprint used to create a new instance of an object. An instance is a virtual manifestation of an object. To compare this to the real world, when you go to a restaurant and you order something you get a new instance of a Meal class. You get brand new food that has just been cooked in your plate, but you also reuse an older instance of the Plate class since they didn’t made a new plate for you; they simply washed it.

You might argue that the food is not really new either, that it has simply been cooked and not spawned into the world from nowhere specifically for you, and you would be right. But remember that I mentioned it was a new instance of the Meal class. A Meal isn’t just meat and vegetables. It is a unique combination of those things, in specific proportions, with a specific presentation. While it is a brand new Meal, it most likely still depends on the original ingredients. To instantiate (create an instance of) this Meal, you would probably need to give it a few instances of Carrots, Steak and whatnot. The whole thing is just so much more than the sum of its parts that it deserves its own blueprint, its own recipe, to create it.

The concept of blueprints (classes) versus actual object (instances) is very important in the OOP world. There are things that you can do on blueprint that you cannot do on an actual object and vice versa. What is also important to understand is that you will only write code for blueprints. Instances are handled by the machine. You can tell the machine to create an instance, but you cannot tell it how to jump between different sections of your code. This, the machine will figure it out by itself based on your blueprints. It is the same as cooking a recipe. You cannot control all the chemical reactions in your cake as it is baking, but you can put together ingredients and actions to get a specific result by following a specific recipe, or blueprint, for this cake.

For our next piece of vocabulary, we will leave the world of food to get in a different context. C# have a concept called namespaces. A namespace is the equivalent of the LEGO box of your dreams. It does a similar job as folders for your files but with objects. A concrete example for the use of namespaces would be dealing with an Application class. On a computer an Application is a block of code that initiate a process and probably provides an icon, a name and a few other things. It makes sense to have an Application class in your programs to start the whole machinery. Now what would you do if you were working on a software such as the LinkedIn social network; an Application where you can apply on a job which would very likely create a new instance of an Application class which would contain details about you, the recipient and some details about the position you are applying for. Those clearly are different types of Applications. One is a software, the other is a resume in some business’ emails account.

This is where namespaces and their dot-syntax become handy. They let you define an Application class which will take care of the software part within the “LinkedIn” namespace and a Application class which will take care of the job part within the “LinkedIn.Business.Entities” namespace. You will recognize the use of the dot-syntax used to express a series of nodes in a hierarchy.

If you are not familiar with this syntax, here is a little explanation of how it works. Basically, you would dig through the nodes like this: root.level1.level2.level3… In this example, only the rightmost element is a class. All the elements together defines its fully qualified name or FQN. Application is the class and LinkedIn.Bussiness.Entities is the namespace. LinkedIn would be the root namespace (equivalent of a root folder) containing everything. Then, there would be a Bussiness sub-namespace (like a sub-folder) in it and so on. Obviously, since namespaces are just like folders, you get to pick their names. Don’t try to be imaginative. If you can reuse a name used by everyone else, please do so. Terms like “Business” and “Entities” are good examples of commonly used namespaces.

Namespaces are also really handy to help you layer your code. In the example I just gave you, you can clearly see that we have a namespace that regroup everything in our application (LinkedIn), a namespace that regroups everything that is related to the core logic or business logic of our application (LinkedIn.Business) and finally an other namespace that regroups all of the entities or data structures that the business logic uses (LinkedIn.Business.Entities). We could also create a LinkedIn.Views namespace that would contain everything used to display the data, a LinkedIn.DataAccess namespace that would contain everything used to load the data from a file, database or external web service, etc.

With this kind of structure in place, it becomes really simple to create objects that have only one responsibility and to regroup the code that interacts together in a common bucket. Obviously, the goal of OOP is not to prevent you from sharing information between objects or execute code between objects. It is only to help you control where those calls comes from, where they can go and what data can change in the process.

Like I said, there is no reason not to regroup things in those virtual boxes. They cost absolutely nothing. They simply are the best virtual LEGO boxes ever! OK, they do have a cost… in bytes and keystrokes. If you would always have to reference the full class name including its namespace every time you would need it, you would waste a lot of time typing them for nearly no gain. Since each object is supposed to handle only one responsibility and that related objects should share the same namespace, it shouldn’t happen too often that you end up manipulating both types of Application classes in a single object. To help you save your fingers, there is one last keyword I would like to introduce to you. This keyword is the using keyword (also called import in other languages). You can simply type “using LinkedIn.Business.Entities;” at the top of a file and then all of the blueprints within this namespace will become available as if they were in the current namespace for the current file. Then, if you really need to use the other Application class you can simply specify its full name for that one time.

Namespaces are not something that you will use a lot in our first lessons but they will quickly become your best friend as we go forward and write more and more code. My point here is not that you know how to use these tools in details and properly understand all of their properties. Instead, see this as an high-level overview to concepts that we will use in the following sessions. It is important to know that those concept exists and what problem they try to solve but not necessarily how to use them yourself. Still, with what we have seen here, you should be able to figure it out when you see your first few code samples.

## Just about there…

What have we learned so far? We have learned that in most modern languages, we write code in form of objects that keeps their properties and actions tight under their own control and that they should try to limit themselves to one and only task. We have learned that we use the class keyword to define one of those objects and that we can then create instances of those class to end up with a virtual copy of an object that we can interact with. Finally, we have learned that those blueprints can be organized within namespaces that acts as folders for classes and that can be imported within the current file with the using keyword for easy access.

Wow… that looks like a lot of stuff… and it is! This is the basics of how to organize code within an application. As you might have guessed, the next post will be part two of the tool making topic. We will look into the various keywords involved in creating what goes inside those blueprints and how you can define actions and properties in them. We will also look at where those namespaces and objects lives in your computer and how they get executed.